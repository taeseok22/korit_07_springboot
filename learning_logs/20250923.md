```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.NoArgsConstructor;

@Entity
@NoArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private String firstName, lastName;

    // Lombok 사용하지 않고, 기본 생성자 및 ownerId 를 제외한 RequiredArgsConstructor를 생성할 것
    // Lombok 사용하지 않고, 각 field에 대한 getter setter를 생성할 것
    public Owner(String firstName,String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Long getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(Long ownerId) {
        this.ownerId = ownerId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
```

Lombok이 적용된 Entity Class의 구조
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName;
    private final String lastName;
}
```
- `@NoArgsConstructor(force = true)` : final 필드가 있는 경우에도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해주기 때문에 `final` 키워드가 붙은 경우에도 JPA에서 요구되는 기본 생성자를 만들 수 있고, `@RequiredArgsConstructor` 와도 충돌하지 않는다.

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들겁니다. 일대다 관계는 소유자가 한 명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미입니다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaReposiotry를 상속 받아야 합니다.

이상의 일대다 관계를 추가하려면 `@ManyToOne`과 `@OneToMany` 애너테이션(jakarta.persistence)을 이용해야 한다. 외래 키 포함한 Car 엔티티 클래스에선 `@ManyToOne`을 사용할거다(이거때문에 위에 부분 복사해왔다.) 그리고 외래키를 추가했기 때문에 field구성이 달라져야댄다.

그럼 DB 적으로 봤을 땐 car table에다가 외래키인 ownerId를 추가하는 개념이라고 볼 수 있기 때문에 Car entity class엔 Owner 관련 field를 추가해야 한다. 그럼 새로 추가된 field에 대한 getter / setter도 요구될거다. 모든 JOIN 관계에선 FetchType.LAZY를 이용하는 것이 좋다. 대다(toMany) 관계의 경우엔 FetchType.LAZY가 기본값이므로 정의할 필욘 없지만 대일(toOne) 관계의 경우엔 반드시 명시해줘야 한다.

FetchType : DB에서 데이터를 검색하는 전략을 정의. 속성값으론
  EAGER : 즉시 검색
  LAZY : 지연 검색
우리 예제에선 지연 검색(LAZY)은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연간된 모든 자동차를 검색한다는 의미다. 반면 즉시 검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색한다.

```java

package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private final String firstName;

    @NonNull
    private final String lastName;

    // 소유자는 다수의 차들을 가질 수 있기 때문ㅇ ㅔCollections를 사용.
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}
```
이상의 코드에서 `@Data` 를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 getter / setter를 코드러 써뒀다. 반면에 `@Getter, @Setter`를 명시해둔 Owner 클래스엔 cars 관련 getter / setter를 안썼다. 당연히 프로젝트 할땐 setOwner() / getOwner()를 코드로 쓸 필요가 없다.

Owner class의 `@OneToMany` 애너테이션엔 특성이 있다.
1. cascade 속성은 삭제 / 업데이트 시 연속 효과가 적용되는 방법을 지정함.
  - ALL로 설정하게 되면 모든 작업이 연속적으로 적용된다.
  - 예를 들어 Owner를 삭제하게 되면 그 소유자와 연결된 Car 객체들도 전부 다 삭제된다.
2. mappedBy="owner" 속성 설정 : Car 클래스 사이에 이 관계의 외래 키인 owner 필드가 존재함을 명시함.

SQL을 배운 우리가 좀 어색하게 느껴질 수 있는 것은 ownerId 필드 하나만 가지고 와서 연결짓는게 아니라 Owner 클래스를 통째로 들고와서 Car에 field로 삼는다는 점이다.

## H2 -> MariaDB로 이식
h2 version을 push한다.

git add .
git commit -m "feat: h2 인메모리 설정 관련 코드"
git push

build.gradle에 h2 관련 의존성 있는지 여부
application.properties에서 h2 관련으로 접속하는지 여부다.

MariaDB로 바꾼다는 말은 build.gradle / application.properties 설정을 바꿀거라는 의미가 된다.

1. HeidiSQL에서 관련 DB를 생성
2. 새 DB 생성 -> cardb 이부분이 application.properties 와 일치해야 한다.
3. build.

```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
//	runtimeOnly 'com.h2database:h2'
	runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'

	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```
4. application.properties에 데이터베이스 연결 정의
```property
spring.application.name=cardatabase 
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
```
spring.jap.generate-ddl=true 설정은 JPA가 데이터베이스를 초기화 해야 하는지(true / false) 여부를 정의한다.

spring.jpa.hibernate.ddl-auto=create-drop 설정은 데이터베이스 초기화의 작동을 정의. 이용 가능한 값은 none / validate / update / create / create-drop으로 기본값은 db마다 다르다. h2인 메모리의 경우엔 기본적으로 create-drop인데, mariadb는 none다.
  - create : 애플리케이션이 시작될 때 데이터베이스를 생성하기만 함(그래서 create로 해놓고 동일한 테이블명 설정해두면 오류남)
  - update : 데이터베이스를 생성하고 스키마가 변경되면 수정.
  - create-drop : 애플리케이션이 시작될때마다 dv를 생성하고 중지될 때마다 삭제 -> 그래서 잦은 변경사항이 있는 개발 환경에선 얘를 쓰는 편이다.

springboot 프로젝트 생성
entity class - repository의 관계성 (Lombok 유무에 따른 코드 라인 변경 사항 작성)
mariadb 이식과 관련된 설정

이상가지 작성했다고 가정했을 때 CarDatabaseApplication에 CommandLineRunner를 활용한 더미 데이터를 넣는 것이 좀 번거롭게 느껴질 수 있다. 우린 이미 SQL문을 배웠고 그렇다면 곧장 테이블에 값을 넣을 수 있을 것 같으니까.

근데 create-drop 때문에 할 때마다 날라가서 쿼리문을 째로 복사해뒀다가 실행할 때마다 붙여넣든지, 아니면 길고 귀찮지만 main 부분에 작성해두든지 해야할 거다.

# RESTful 