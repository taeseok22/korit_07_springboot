# Spring Security 추가 정리
## 정의
- Spring 기반의 애플리케이션 보안(Authentication / Authorization)을 위한 표준 프레임워크. 서블릿 필터(Servlet Filter) 체인을 기반으로 동작하며 웹 요청에 대한 보안을 체계적으로 처리함. 단순한 록읜 기능 뿐만 아니라, CSRF 공격 방지, 세션 관리, 권한 기반 접근 제어 등 포괄적인 보안 기능을 제공.
## 특징
1. 포괄적 보안 기능 : 인증(Authentication)  인가 :(Authorization) 뿐 아니라 일반적인 웹 보안 위협으로부터 애플리케이션을 보호.
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정할 수 있음(우리가 해야한다는 뜻).
3. 서블릿 필터 기반 : 요청이 컨트롤러에 도달하기 전에 여러 보안 필터를 거치게 하여 선제적인 보안 검사를 수행.
4. SpringBoot와의 통합 : `spring-boot-starter-security` 의존성만 추가하면 기본적인 보안 기능이 자동 설정되어 빠르게 적용가능(default 로그인 페이지가 생겼고 password가 콘솔에 찍혔다).
## SecurityConfig
- Spring Security의 보안 구성(Config)을 담당하는 Java 설정 클래스로 해당 클래스엔 `@Configuration, @EnableWebSecurity` 애너테이션을 추가하여 Spring Security의 웹 보안 설정을 활성화 하고 커스터마이징 할 수 있다.

- 과거엔 `WebSecurityConfigurerAdapter`를 상속 받아서 configure() 메서드를 오버라이딩하는 방식으로 사용했었지만 SpringBoot 3.x 버전부턴 SecurityFilterChain 빈(bean)을 등록하는 방식이 권장됨. 현재 방식은 컴포넌트 기반의 구성으로 더욱 모듈화되고 유연한 보안 구성이 가능.

### SecurityConfig의 핵심 역할
1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나 특정 권한(Role)을 가진 사용자만 접근 가능하도록 설정 가능.
2. 인증 방식 설정 : 폼 로그인(Form Login), HTTP Basic 인증 0Auth2 로그인 등 다양한 인증 방식을 설정하고 커스터마이징 가능.
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직을 정의.
4. 비밀번호 암호화 : `PasswordEncoder` 를 빈으로 등록해 사용자의 비밀번호를 안전하게 암호화 하고 검증하는 방식을 지정.
5. CSRF, CORS 설정 : CSRF 보호 기능을 활성화하거나 비활성화 하고 CORS 정책을 구성.

### SecurityConfig 코드 예시
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
  // 비밀 번호 등록을 위한 PasswordEncoder 빈을 등록
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCyptPasswordEncoder();
  }

  // Spring Security의 filterChain을 작성
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
    // 1. 인가(Authorization) 구성
      .authorizeHttpRequests(authorize -> authorize
        .requesMatchers("/users/**").authenticated() // /user/** 경로는 인증된 user만 가능
        .requesMatchers("/manager/**").hasAnyRole("ADMIN", "MANAGER") // /manager/** 경로는 role이 ADMIN이거나 MANAGER인 user만 가능
        .requesMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 role이 ADMUN인 user만 가능
        .anyRequest().permitAll() // 나머지 경로에 대한 요청들은 접근 허용함.
        )
        // 2. 폼 로그인(Form Login) 구성
        .formLogin(form -> form
          .loginPage("/login")    // 커스텀 로그인 페이지의 URL 지정
          .loginProcessingUrl("/loginProc") // 로그인 처리 URL
          .defaultSucessUrl("/")    // 로그인 성공 시 이동할 default URL
          .permitAll()    // 로그인 페이지는 모든 사용자가 접근 가능
        )
        // 3. 로그아웃 설정
        .logout(logout -> logout
          .logoutUrl("/logout") // 로그아웃 처리 URL
          .logoutSuccessUrl("/")  // 로그아웃 성공 시 이동할 URL
          .invalidateHttpSession(true)  // 세션 무효화
          .deleteCookies("JSESSIONID")   // 쿠키 삭제
        )
        // 4. CSRF 보호 비활성화(API 서버의 경우)
        .csrf(csrf -> csrf.disable());
  }
}
```
- 이상의 코드의 상세 설명
  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙을 구성
    - requestMatchers() : 특정 URL 패턴을 지정
    - authenticated() : 인증된 사용자만 접근 허용
    - hasAnyRole(), hasRole() : 특정 역할을 가진 사용자만 접근 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE_" 접두사가 붙어서 처리됨.(예시 : hasRole("ADMIN")은 "ROLE_ADMIN" 역할을 확인한다는 의미다).
    - permitAll() : 모든 사용자의 접근을 허용.
    - anyRequest() : 위에서 설정한 규칙 외의 모든 요청을 의미. _그래서 인가 규칙의 경우 구체적인 경로를 먼저 설정하고 포괄적인 경로는 나중에 구성해야 한다._
  2. formLogin : 폼 기반 로그인을 설정
    - loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로를 지정.
    - loginProcessingUrl() : 로그인 폼 데이터를 처리할 URL을 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증을 처리함.
    - defaultSuccessUrl() : 로그인 성공 후 사용자를 리디렉션할 기본 페이지 지정.
  3. logout : 로그아웃 관련 설정.
    - logouturl() : 로그아웃을 처리할 URL을 지정.
    - logoutSuccessUrl() : 로그아웃 성공 후 리디렉션 ㅗ딜 페이지 지정.
    - invalidateHttpSeesion(true) : 로그아웃 시 HTTP 세션을 무효화.
    - deleteCookies("JSESSIONID") : 로그아웃 시 지정된 쿠키 삭제.
  4. csrf(csrf -> csrf.disable()) : CSRF 보호 기능을 비활성화. 세선 기반 인증이 아니라 _JWT와 같은 토큰 기반 인증을 사용하는 API 서버의 경우 일반적으로 비활성화_

Java 관련 vs code
Cod Runner -> Java 프로젝트 실행시키려면 필요.
Debugger for Java
Extension Pack for Java

AppUser / AppUserRepository를 생성함으로써 DB에 AppUser 관련 테이블 생성됐고 Spring Security 의존성을 도입해 default login이 가능함.

이제 보안 관련 로직을 현재 프로젝트의 MVC 패턴에 맞게 설정할 필요가 있다.

1. 사용자 인증을 위한 Service 계층 구현. : Spring Security가 데이터베이스의 사용자 정보를 기반으로 인증을 수행할 수 있도록 userDetailsService를 구현할거다.
  - service 패키지 내에 UserDetailsServiceImpl 클래스 생성 UserDetailsService를 _구현_

```java
package com.example.cardatabase4.service;

import com.example.cardatabase4.domain.AppUser;
import com.example.cardatabase4.domain.AppUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Optional;

import static org.springframework.security.core.userdetails.User.withUsername;

@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    private final AppUserRepository appUserRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = appUserRepository.findByUsername(username);

        UserBuilder builder = null;
        if (user.isPresent()) {
            AppUser currentUser = user.get();       // user 자체는 Optional 자료형이지 AppUser가 아니다.
            builder = withUsername(username);
            builder.password(currentUser.getPassword()).roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User Not Found");
        }
        return builder.build();
    }
}
```
이상의 코드는 cardatabase_2의 UserDetailsServiceImpl과 코드라인이 일부 변경됐다. 그 과정 중 AppUserRepository의 내부에 findByUsername(String username) 추상 메서드를 정의했는데 일반적인 방법으로 한 것이 아니라 오류를 발생시킨 다음에 intellij의 내부 기능을 사용하여 자동 생성을 했었다.

또한 User 클래스를 가지고 온 것이 아니라 static 메서드를 import 하는 방식으로 코드라인을 줄였다.

builder를 가지고 온 김에 chaining method를 도입해 builder 객체를 생성했었따.

2. JWT 토큰 생성 및 검증 Service 구현 : 로그인 성송 시 JWT 토큰을 발급하고 이후의 모든 요청에서 토큰을 검증하는 JwtService를 만든다.
  - 관련 의존성 추가하고
  - service 패키지에 JwtService 클래스 생성

3. 로그인 Controller 및 관련 클래스 생성 : 로그인 요청 시엔 ID와 비번을 담을거다. 그니까 이게 꼭 AppUser Entity가 아님. 그 때 우린 새로 하나 만들었다.
  - domain 패키지 내에 AccountCredentials Record 만들어
4. JWT 인증 필터 및 예외 처리 구현 : `/login` 을 제외한 모든 API 요청을 가로채서 JWT 토큰의 유효성을 검사하는 Filter를 만들거다.
  - 루트 프로젝트 패키지에 AuthencationFilter 클래스 생성
5. AuthEntryPoint(인증 실패 처리) : 로그인 실패시 현재대로 라면 403이 떠야함. (근데 우리 cardatabase4엔 아직 SecurityConfig가 없어서 실행도 안됨.) 이 부분을 401 처리하기 위한 부분이다.
  - 루트 프로젝트 패키지에 AuthEntryPoint 클래스 생성

6. 이상가지 상황을 반영한 SecurityConfig 작성.
  이상까지 작성했을 때 cardatabase_2와 좀 다른 부분들이 있는데 보편적으론 JwtService 시작지점에 `@Service / @Component` 의 차이다. 컴포넌트 애너테이션은 클래스 자체를 bean 등록하기 위한 것이라고 이미 설명했다. 서비스 애너테이션을 ctrl + 클릭 해보면 애초에 서비스 애너테이션이 컴포넌트 애너테이션을 상속받았음을 확인할 수 있다. 동일한 방식으로 `@RestController`도 ctrl + 클릭하면 `@Controller` 를 상속 받았고 또 얘를 클릭하면 내부에 `@Component`가 있음을 확인 가능. 그럼 어차피 특정 클래스는 특정 역할을 한다고 애너테이션 명시 하는 순간 `@Component`가 적용된다고 볼 수 있다.
7. 현재 AppUser를 객체 추가하려면 SQL문을 통하거나 혹은 CommandLineRunner를 통해서 해야할 것 같다. 이를 통해 생성된 AppUser 객체를 가지고 로그인 성공 시 / 실패 시 를 확인하면 spring-data-rest 없는 상태의 부분이 구현될 것 같다.

# 시험 예시 문제
온라인 서점에서 판매할 일반 도서(Book)와 전자책(EBook)을 관리하는 시스템을 구축하려함. Book 클래스를 상속받는 EBook 클래스를 완성하고 각 클래스의 객체를 생성하여 정보를 출력하는 프로그램 작성

요구사항 명세서 :
1. Book 클래스는 title (제목)과 author (저자)를 필드로 가짐.
2. EBook 클래스는 Book 클래스를 상속받으며 fileSize (파일 크기) 필드를 추가로 가짐.
3. 각 클래스는 필드 정보를 출력하는 displayInfo() 메서드를 가짐. EBook 클래스의 displayInfo()는 Book의 메서드를 오버라이딩하여 파일 크기 정보까지 함께 출력해야함.
4. main 메서드에서 Book과 EBook 객체를 각각 생성하고 displayInfo() 메서드를 호출해 아래 "실행 예" 와 같이 출력되도록 코드 완성해.

실행 예
제목 : 자바의 정석, 저자 : 남궁성
제목 : 스프링3부트 3 백과사전, 저자 : 김영환, 파일 크기 : 20.5MB